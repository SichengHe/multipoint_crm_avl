# Purpose

In the repo, we generate the multi-scenario load for a wing structure (uCRM-9).
The truss model of the wing was developed in a separate repo and we saved here in this repo for different grid sizes (under `/Wings`).
The aerodynamic load is computed using AVL.
The load is first computed over an underlying aerodynamic grids within AVL.
Then we transfer the load to the structure.

Following is a detailed explanations of functions of different files.
The overall file structure is

* `driver.py` is the main function.
In the file, we have the input geometry and flight conditions.
This file will set up the cases, run the AVL and transfer the load to the structures.
* `aerodynamic` stores files for aerodynamic load computation for all scenarios.
The `wing_lehigh.avl` serve as a template.
The outputs are the load on the aerodynamic grids and the aerodynamic grids coordinates.
* `Wings` stores the structure of the wing with different fidelity (grid sizes).
* `transfer` transfers the aerodynamic load to the structure.
A very simple transfer method is applied here: 
we associate each aerodynamic node to the closest truss node.
After this, we sum the aerodynamic load contribution for each truss node.
In the process, we drop the moment contribution and only keep the force.
We also split the load equally for the upper and lower surface of the truss.

The outputs are stored in `OUT_AERO` and `OUT_STRUCT`.
The former are the aerodynamic load and aerodynamic grid coordinates computed from AVL.
The latter are the loads on different grids of the trusses.

Something worth notice is the way we compute and set $C_L$.

* For the cruise conditions, the $C_L$ is given for the reference area $A_\text{ref}$ of the wing and that is different from what we give AVL for computation $A_\text{AVL}$ (due to the part hidden inside the fuselage).
Thus, we scale the lift coefficient for AVL to keep a same load generated by the wing: $C_\text{L, AVL} = \frac{A_\text{ref}}{A_\text{AVL}} C_L$.
* For the computation of $C_L$ for the maneuver condition, we use $A_\text{ref}$ and later scale the computed $C_L$ up according to the aforementioned reason.


# TODO

* The `transfer.py` class might be overly simple.